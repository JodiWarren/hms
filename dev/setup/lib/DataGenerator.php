<?php
/**
 *
 * PHP 5
 *
 * Copyright (C) HMS Team
 *
 * Licensed under The MIT License
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright     HMS Team
 * @package       dev.Setup
 * @license       MIT License (http://www.opensource.org/licenses/mit-license.php)
 */

define('CAKE_PATH', '../../../lib/Cake/');
define('APP_PATH', '../../../app/');

require_once (CAKE_PATH . 'Core/App.php');
require_once (CAKE_PATH . 'Core/Object.php');
require_once (CAKE_PATH . 'Event/CakeEventListener.php');
require_once (CAKE_PATH . 'Model/Model.php');
require_once (CAKE_PATH . 'Utility/String.php');
require_once (APP_PATH . 'Model/AppModel.php');
require_once (APP_PATH . 'Model/Status.php');
require_once (APP_PATH . 'Model/Account.php');
require_once (APP_PATH . 'Model/Pin.php');
require_once (APP_PATH . 'Model/Group.php');
require_once (APP_PATH . 'Lib/CsvReader/CsvReader.php');

require_once ('Utils.php');

/**
 * This script is used to generate realistic(ish) data for use when manually testing HMS.
 * It is mainly powered by data generated by http://www.fakenamegenerator.com/
 * Data provided by http://www.fakenamegenerator.com/ is used under the
 * Creative Commons Attribution-Share Alike 3.0 United States license.
 */
class DataGenerator {

/**
 * The stock data used to populate other fields.
 * @var array
 */
	private $__stockData = array();

/**
 * List of ataken usernames
 * @var array
 */
	private $__takenUsernames = array();

/**
 * Array of members.
 * @var array
 */
	private $__members = array();

/**
 * Array of which members are in which groups.
 * @var array
 */
	private $__membersGroup = array();

/**
 * Array of accounts.
 * @var array
 */
	private $__accounts = array();

/**
 * Array of pins.
 * @var array
 */
	private $__pins = array();

/**
 * Array of rfid tags.
 * @var array
 */
	private $__rfidTags = array();

/**
 * Array of status updates.
 * @var array
 */
	private $__statusUpdates = array();

/**
 * Array of mailing lists.
 * @var array
 */
	private $__mailingLists = array();

/**
 * Array of mailing list subscriptions.
 * @var array
 */
	private $__mailingListSubscriptions = array();

/**
 * Array of email records.
 * @var array
 */
	private $__emailRecords = array();

/**
 * Constructor
 */
	public function __construct() {
		$this->__parseCsv('./FakeNameGeneratorData.csv');
		$this->__populateMailingLists();
	}

/**
 * Populate the mailing lists array.
 */
	private function __populateMailingLists() {
		$this->__mailingLists = array(
			array(
				'id' => 'us8gz1v8rq',
				'web_id' => '30569',
				'name' => 'Nottingham Hackspace Announcements',
				'date_created' => '2012-06-28 19:12:00',
				'email_type_option' => '1',
				'use_awesomebar' => false,
				'default_from_name' => 'Nottingham Hackspace',
				'default_from_email' => 'info@nottinghack.org.uk',
				'default_subject' => 'An Announcement From Nottingham Hackspace',
				'default_language' => 'en',
				'list_rating' => '3.5',
				'subscribe_url_short' => 'http://eepurl.com/ncaln',
				'subscribe_url_long' => 'http://nottinghack.us5.list-manage.com/subscribe?u=a4e59e4c29bd40e76419a037b&id=us8gz1v8rq',
				'beamer_address' => 'YTRlNTllNGMyOWJkNDBlNzY0MTlhMDM3Yi02YTkzMzc3ZS05ZTU5LTQ2ZmUtOTQ5Ni04ODQyYTAzOWVlN2Y=@campaigns.mailchimp.com',
				'visibility' => 'pub',
				'member_count' => 0,
				'unsubscribe_count' => 6,
				'cleaned_count' => 1,
				'member_count_since_send' => 8,
				'unsubscribe_count_since_send' => 0,
				'cleaned_count_since_send' => 0,
				'campaign_count' => 24,
				'grouping_count' => 0,
				'group_count' => 0,
				'merge_var_count' => 2,
				'avg_sub_rate' => 22,
				'avg_unsub_rate' => 1,
				'target_sub_rate' => 1,
				'open_rate' => 46.108140225787,
				'click_rate' => 13.967310549777,
			),
			array(
				'id' => '455de2ac56',
				'web_id' => '64789',
				'name' => 'Nottingham Hackspace The Other List',
				'date_created' => '2013-01-12 14:43:00',
				'email_type_option' => '1',
				'use_awesomebar' => false,
				'default_from_name' => 'Nottingham Hackspace',
				'default_from_email' => 'info@nottinghack.org.uk',
				'default_subject' => 'Something Else From Nottingham Hackspace',
				'default_language' => 'en',
				'list_rating' => '2.3',
				'subscribe_url_short' => 'http://eepurl.com/sdfet',
				'subscribe_url_long' => 'http://nottinghack.us5.list-manage.com/subscribe?u=a4e59e4c29bd40e76419a037b&id=455de2ac56',
				'beamer_address' => 'YTRlNTllNGMyOWJkNDBlNzY0MTlhMDM3Yi02YTkzMzc3ZS05ZTU5LTQ2ZmUtOTQ5Ni04ODQyYTAzOWVlN2Y=@campaigns.mailchimp.com',
				'visibility' => 'pub',
				'member_count' => 0,
				'unsubscribe_count' => 2,
				'cleaned_count' => 1,
				'member_count_since_send' => 3,
				'unsubscribe_count_since_send' => 1,
				'cleaned_count_since_send' => 0,
				'campaign_count' => 2,
				'grouping_count' => 0,
				'group_count' => 0,
				'merge_var_count' => 2,
				'avg_sub_rate' => 3,
				'avg_unsub_rate' => 1,
				'target_sub_rate' => 1,
				'open_rate' => 24.108140225787,
				'click_rate' => 91.967310549777,
			),
		);

		// Subscribe some random e-mails
		$emailChars = array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'u', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z');
		$emailDomains = array(
			'foo.org',
			'example.com',
			'bar.net',
			'loa.fr',
			'bmail.co.uk',
		);

		foreach ($this->__mailingLists as $list) {
			$numToAdd = rand(10, 30);
			for ($i = 0; $i < $numToAdd; $i++) {
				$timestamp = rand(strtotime('last year'), time());

				$numCharsInEmail = rand(4, count($emailChars) - 1);

				$email = '';
				for ($j = 0; $j < $numCharsInEmail; $j++) {
					$email .= $emailChars[array_rand($emailChars)];
				}

				$email .= '@';
				$email .= $emailDomains[array_rand($emailDomains)];

				$this->__subscribeEmailToList($email, $list['id'], $timestamp);
			}
		}
	}

/**
 * Parse a CSV file, adding the data to the stockData array.
 * 
 * @param $filepath string Path to the .csv file to try and parse.
 */
	private function __parseCsv($filepath) {
		$csvReader = new CsvReader();

		if ($csvReader->readFile(makeAbsolutePath($filepath))) {
			$numLines = $csvReader->getNumLines();

			// If the .csv is sane, the first line is the headers
			$headers = $csvReader->getLine(0);

			if ($headers != null) {
				for ($i = 1; $i < $numLines; $i++) {
					// For every line, convert the indexed array to an associated array
					// using the headers as keys

					$line = $csvReader->getLine($i);
					if ($line != null && count($line) == count($headers) ) {
						$assocLine = array();
						$numLineParts = count($line);
						for ($j = 0; $j < $numLineParts; $j++) {
							$assocLine[$headers[$j]] = $line[$j];
						}

						array_push($this->__stockData, $assocLine);
					}
				}
			}
		}
	}

/**
 * Get the SQL version of a value.
 * 
 * @param mixed $value The value to transform.
 * @return string SQL version of the value.
 */
	private function __sqlize($value) {
		if (is_string($value)) {
			// Note that this escaping is not secure
			// but it's about the best we can do without connecting
			// to a database.
			return "'" . str_replace("'", "\'", $value) . "'";
		}

		if (is_numeric($value)) {
			return (string)$value;
		}

		if ($value == null) {
			return 'NULL';
		}
	}

/**
 * Get the MYSql of an array
 * 
 * @param array $array The array to use.
 * @param string $title The name of the table
 * @return string MYSql string of array data.
 */
	private function __getSql($array, $title) {
		$headers = array_keys($array[0]);
		$formattedHeaders = array_map( function ($val) {
			return "`$val`";
		}, $headers);

		$sql = "INSERT INTO `$title` (";
		$sql .= implode(', ', $formattedHeaders);
		$sql .= ") VALUES" . PHP_EOL;

		$numItems = count($array);
		for ($i = 0; $i < $numItems; $i++) {
			$values = $array[$i];

			$formattedValues = array_map( function ($val) {
				return $this->__sqlize($val);
			}, $values);

			$sql .= "(" . implode(', ', $formattedValues) . ")";

			if ($i < count($array) - 1) {
				$sql .= ',';
			} else {
				$sql .= ';';
			}
			$sql .= PHP_EOL;
		}

		return $sql;
	}

/**
 * Get an SQL string of the members data.
 * 
 * @return string SQL string for the members data.
 */
	public function getMembersSql() {
		return $this->__getSql($this->__members, 'members');
	}

/**
 * Get an SQL string of the membersGroup data.
 *
 * @return string SQL string for the membersGroup data.
 */
	public function getMembersGroupSql() {
		return $this->__getSql($this->__membersGroup, 'member_group');
	}

/**
 * Get an SQL string of the accounts data.
 *
 * @return string SQL string for the accounts data.
 */
	public function getAccountsSql() {
		return $this->__getSql($this->__accounts, 'account');
	}

/**
 * Get an SQL string of the pins data.
 *
 * @return string SQL string for the pins data.
 */
	public function getPinsSql() {
		return $this->__getSql($this->__pins, 'pins');
	}

/**
 * Get an SQL string of the RFID tags data.
 *
 * @return string SQL string for the RFID tags data.
 */
	public function getRfidTagsSql() {
		return $this->__getSql($this->__rfidTags, 'rfid_tags');
	}

/**
 * Get an SQL string of the status updates data.
 *
 * @return string SQL string for the status updates data.
 */
	public function getStatusUpdatesSql() {
		return $this->__getSql($this->__statusUpdates, 'status_updates');
	}

/**
 * Get an SQL string of the mailing lists data.
 *
 * @return string SQL string for the mailing lists data.
 */
	public function getMailingListsSql() {
		return $this->__getSql($this->__mailingLists, 'mailinglists');
	}

/**
 * Get an SQL string of the mailing list subscriptions data.
 *
 * @return string SQL string for the mailing list subscriptions data.
 */
	public function getMailingListSubscriptionsSql() {
		return $this->__getSql($this->__mailingListSubscriptions, 'mailinglist_subscriptions');
	}

/**
 * Get an SQL string of the email record data.
 *
 * @return string SQL string for the email record data.
 */
	public function getEmailRecordSql() {
		return $this->__getSql($this->__emailRecords, 'hms_emails');
	}

/**
 * Generate a new member record
 *
 * @param int $membershipStage The stage of membership this member should be at, see Status model for details.
 * @param array $details Optional array of details that will be forced on the member being generated.
 */
	public function generateMember($membershipStage, $details = array()) {
		$memberId = count($this->__members) + 1;

		$creditLimit = 0;
		$balance = 0;
		$joinDate = '';
		$accountId = null;

		// Make it so they registered some time in the last year
		$now = time();
		$lastYear = strtotime('last year');
		$registerTimestamp = rand($lastYear, $now);

		if ((int)$membershipStage >= Status::CURRENT_MEMBER) {
			$creditLimit = 5000;
			$balance = rand(-$creditLimit, 0);

			$joinDate = date('Y-m-d', $registerTimestamp);

			$accountId = $this->__generateAccount();
			$this->__generatePin($memberId, $registerTimestamp);

			// Has this member set up access yet?
			// Pick a date within a week of the join date
			// and if that date has passed then member has set up a card
			$weekAfterJoin = strtotime('+1 week', $registerTimestamp);
			$registerTime = rand($registerTimestamp, $weekAfterJoin);
			if ($registerTime <= $now) {
				$this->__registerCard($memberId, $registerTime);
			}

			// Add the member to some random groups if they're a current member
			if ($membershipStage == Status::CURRENT_MEMBER) {
				// Will always be in current members group
				$groupList = array( Group::CURRENT_MEMBERS );

				$possibleGroups = array(
					Group::FULL_ACCESS,
					Group::GATEKEEPER_ADMIN,
					Group::SNACKSPACE_ADMIN,
					Group::MEMBERSHIP_ADMIN,
				);

				$numGroupsToAdd = rand(0, 2);
				for ($i = 0; $i < $numGroupsToAdd; $i++) {
					$index = array_rand($possibleGroups);
					$groupId = $possibleGroups[$index];
					array_splice($possibleGroups, $index, 1);

					array_push($groupList, $groupId);
				}

				// Groups can be overriden by the details array
				if ( isset($details['groups']) ) {
					$groupList = $details['groups'];
				}

				$this->__setMemberGroups($memberId, $groupList);
			}
		}

		// Need to generate status updates for all levels of membership
		// Spread the updates over some time
		$firstStatusUpdateTime = strtotime('-2 weeks', $registerTimestamp);
		$currentStatusUpdateTime = $firstStatusUpdateTime;
		for ($i = 0; $i < $membershipStage; $i++) {
			// The 'admin' making the change is the member
			// until the later membership stages
			$adminId = $memberId;
			if ($i >= Status::PRE_MEMBER_2 && count($this->__members) > 0) {
				$adminDataIdx = array_rand($this->__members);
				$adminId = $this->__members[$adminDataIdx]['member_id'];
			}

			$this->__generateStatusUpdate($memberId, $adminId, $i, $i + 1, $currentStatusUpdateTime);

			// Advance the status update time
			// may produce weirdness if it picks a time close to registerTimestamp with a few
			// status updates left to go but it shouldn't matter
			$currentStatusUpdateTime = rand($currentStatusUpdateTime, $registerTimestamp);
		}

		// Generate some unrealistic email records
		$numEmailRecords = rand(1, 4);
		$fromTimestamp = $registerTimestamp;
		$toTimestamp = $now;
		$subjects = array(
			'Contact Details',
			'Banking Details',
			'Membership Update',
			'Door Codes Have Changed',
		);
		for ($i = 0; $i < $numEmailRecords; $i++) {
			$recordTimestamp = rand($fromTimestamp, $toTimestamp);
			$fromTimestamp = $recordTimestamp;
			$subject = $subjects[array_rand($subjects)];
			$this->__generateEmailRecord($memberId, $subject, $recordTimestamp);
		}

		$stockData = $this->__getStockData();

		$firstname = $this->__useValOrDefault($details, 'firstname', $stockData['GivenName']);
		$surname = $this->__useValOrDefault($details, 'surname', $stockData['Surname']);
		$email = $this->__useValOrDefault($details, 'email', $stockData['EmailAddress']);
		$username = $this->__useValOrDefault($details, 'username', $stockData['Username']);

		while (in_array($username, $this->__takenUsernames)) {
			$username .= (string)rand(0, 9);
		}

		$address = array(
			$stockData['StreetAddress'],
			'',
			$stockData['City'],
			$stockData['ZipCode']
		);

		$contactNumber = $stockData['TelephoneNumber'];

		// Subscribe this member to some lists maybe
		foreach ($this->__mailingLists as $list) {
			if (rand(0, 100) <= 70) {
				$this->__subscribeEmailToList($email, $list['id'], $registerTimestamp);
			}
		}

		$unlockText = 'Welcome ' . $firstname;

		// Clear any data that wouldn't be set yet
		if ((int)$membershipStage <= Status::PRE_MEMBER_1) {
			$firstname = null;
			$surname = null;
			$joinDate = '';
			$unlockText = null;
			$balance = 0;
			$creditLimit = 0;
			$username = null;
			$accountId = null;
			$address[0] = null;
			$address[1] = null;
			$address[2] = null;
			$address[3] = null;
			$contactNumber = null;
		}

		array_push($this->__takenUsernames, $username);

		$record = array(
			'member_id' => $memberId,
			'firstname' => $firstname,
			'surname' => $surname,
			'email' => $email,
			'join_date' => $joinDate,
			'unlock_text' => $unlockText,
			'balance' => $balance,
			'credit_limit' => $creditLimit,
			'member_status' => $membershipStage,
			'username' => $username,
			'account_id' => $accountId,
			'address_1' => $address[0],
			'address_2' => $address[1],
			'address_city' => $address[2],
			'address_postcode' => $address[3],
			'contact_number' => $contactNumber
		);

		array_push($this->__members, $record);
	}

/**
 * Create a new e-mail record.
 *
 * @param int $memberId The id of the member the e-mail was sent to.
 * @param string $subject The subject of the e-mail.
 * @param int $timestamp Unix timestamp for the time the e-mail was sent.
 */
	private function __generateEmailRecord($memberId, $subject, $timestamp) {
		$recordId = count($this->__emailRecords) + 1;

		$record = array(
			'hms_email_id' => $recordId,
			'member_id' => $memberId,
			'subject' => $subject,
			'timestamp' => date('Y-m-d H:i:s', $timestamp),
		);

		array_push($this->__emailRecords, $record);
	}

/**
 * Return $array[$key] if it is set, otherwise return $default.
 *
 * @param array $array The array to address.
 * @param mixed $key The index to use.
 * @param mixed $default The value to use if $val us not set.
 * @return mixed $array[$key]  if it is set, otherwise return $default.
 */
	private function __useValOrDefault($array, $key, $default) {
		if (array_key_exists($key, $array)) {
			return $array[$key];
		}

		return $default;
	}

/**
 * Set the groups which a member will belong to.
 *
 * @param int $memberId The id of the member who's groups we're setting.
 * @param array $groupList List of group id's.
 */
	private function __setMemberGroups($memberId, $groupList) {
		// Firstly remove all the current groups assigned to the member
		$numGroups = count($this->__membersGroup);
		for ($i = 0; $i < $numGroups; ) {
			if ($this->__membersGroup[$i]['member_id'] == $memberId) {
				array_splice($this->__membersGroup, $i, 1);
				// Don't increment since we've altered the array
				continue;
			}
			$i++;
		}

		// Now add a record for each of the items in $groupList
		foreach ($groupList as $groupId) {
			$record = array(
				'member_id' => $memberId,
				'grp_id' => $groupId,
			);

			array_push($this->__membersGroup, $record);
		}
	}

/**
 * Generate a status update record
 *
 * @param int $memberId The id of the member.
 * @param int $adminId The id of the admin making the change.
 * @param int $oldStatus The previous status of the member.
 * @param int $newStatus The new status of the member.
 * @param int $timestamp The timestamp of the update.
 */
	private function __generateStatusUpdate($memberId, $adminId, $oldStatus, $newStatus, $timestamp) {
		$recordId = count($this->__statusUpdates) + 1;

		$record = array(
			'id' => $recordId,
			'member_id' => $memberId,
			'admin_id' => $adminId,
			'old_status' => $oldStatus,
			'new_status' => $newStatus,
			'timestamp' => date('Y-m-d H:i:s', $timestamp),
		);

		array_push($this->__statusUpdates, $record);
	}

/**
 * Register an rfid card using the members pin.
 *
 * @param int $memberId The id of the member to register the card to.
 * @param int $registerTime The time the card was registered.
 */
	private function __registerCard($memberId, $registerTime) {
		// Registering a card effects the PIN
		$numPins = count($this->__pins);
		for ($i = 0; $i < $numPins; $i++) {
			if ($this->__pins[$i]['member_id'] == $memberId) {
				$this->__pins[$i]['state'] = 40;
				break;
			}
		}

		// The RFID serial seems to be between 9 and 10 numbers starting with 1
		$serialLenRemaining = 9;
		$serial = '1';
		if (rand() % 2 == 0) {
			$serialLenRemaining = 8;
		}

		for ($i = 0; $i < $serialLenRemaining; $i++) {
			$serial .= rand(0, 9);
		}

		// Make it so the card was used within the last month
		// (all members turn up at-least once a month right? ;) )
		$aMonthAgo = time('-1 month');

		$lastUsedMin = $aMonthAgo;
		// Can't have used it before it was registered...
		if ($aMonthAgo < $registerTime) {
			$lastUsedMin = $registerTime;
		}

		//  Pick a time between then and now
		$lastUsed = rand($lastUsedMin, time());

		// Now add an rfid record
		$record = array(
			'member_id' => $memberId,
			'rfid_serial' => $serial,
			'state' => 10,
			'last_used' => $lastUsed,
		);

		array_push($this->__rfidTags, $record);
	}

/**
 * Generate a new account record.
 *
 * @return int The id of the record.
 */
	private function __generateAccount() {
		$accountId = count($this->__accounts) + 1;

		$accountRef = $this->__generateUniqueEntry($this->__accounts, 'payment_ref', function() {
			return Account::generatePaymentRef();
		});

		$record = array(
			'account_id' => $accountId,
			'payment_ref' => $accountRef,
		);

		array_push($this->__accounts, $record);

		return $accountId;
	}

/**
 * Generate a new pin record
 *
 * @param int $memberId The id of the member the pin belongs to.
 * @param int $joinTimestamp The time the pin was generated.
 */
	private function __generatePin($memberId, $joinTimestamp) {
		$pinId = count($this->__pins) + 1;

		$pin = $this->__generateUniqueEntry($this->__pins, 'pin', function () {
			return Pin::generatePin();
		});

		$record = array(
			'pin_id' => $pinId,
			'pin' => $pin,
			'date_added' => date("Y-m-d H:i:s", $joinTimestamp),
			'expiry' => null,
			'state' => 30,
			'member_id' => $memberId
		);

		array_push($this->__pins, $record);
	}

/**
 * Given an array of array data, a key to the inner array, and a function to generate data, keep generating until the data is unique.
 *
 * @param array $records Array of existing records.
 * @param string $key Index in existing records to check.
 * @param function $genFunc The function used to generate new data.
 * @return mixed A unique value returned from $genFunc.
 */
	private function __generateUniqueEntry($records, $key, $genFunc) {
		$item = '';
		$isUnique = false;
		do {
			$item = $genFunc();
			$isUnique = true;

			foreach ($records as $record) {
				if ($record[$key] == $item) {
					$isUnique = false;
					break;
				}
			}

		} while (!$isUnique);

		return $item;
	}

/**
 * Pop a single element of the stock data and return it.
 *
 * @return array The data requested.
 */
	private function __getStockData() {
		$index = rand(0, count($this->__stockData) - 1);
		$data = $this->__stockData[$index];
		array_splice($this->__stockData, $index, 1);
		return $data;
	}

/**
 * Subscribe an e-mail to a mailing list.
 *
 * @param string $email The e-mail address to subscribe.
 * @param string $listId The id of the list to subscribe them to.
 * @param int $timestamp The time the subscription happened.
 */
	private function __subscribeEmailToList($email, $listId, $timestamp) {
		$recordId = count($this->__mailingListSubscriptions) + 1;

		$record = array(
			'mailinglist_id' => $listId,
			'email' => $email,
			'timestamp' => date('Y-m-d H:i:s', $timestamp),
		);

		array_push($this->__mailingListSubscriptions, $record);

		// Adjust the number of members subscribed to a list
		$numMailingLists = count($this->__mailingLists);
		for ($i = 0; $i < $numMailingLists; $i++) {
			if ($this->__mailingLists[$i]['id'] == $listId) {
				$this->__mailingLists[$i]['member_count']++;
			}
		}
	}
}